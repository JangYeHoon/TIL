# 01. Overview

## What Operating Systems Do

- 운영체제는 컴퓨터의 하드웨어를 관리하고, 하드웨어와 소프트웨어, 사용자를 매개하는 프로그램
- 커널은 운영체제의 핵심이며, 운영체제는 커널과 커널 모듈(Kernel module)들로 구성

### User View

- 운영체제는 사용자가 컴퓨터 자원 사용(Resource utilization)을 신경쓰지 않게 도우며, 사용자가 컴퓨터를 쉽게 이용할 수 있도록 만듬



### System View

- 시스템에게 운영체제는 자원 할당자(Resource Allocator)
- 운영체제는 많은 컴퓨터 자우너들을 관리하는 제어 프로그램(Control program)으로서 동작



## Computer-System Organization

- 일반적인 컴퓨터 시스템은 여러 개의 CPU와 장치 컨트롤러(Device controllers)로 구성
- CPU와 장치 컨트롤러는 공통버스(Common bus)로 이루어져 메모리를 공유



### Computer Startup

- 컴퓨터를 부팅하면 부트스트랩 프로그램(Bootstrap program)이라는 초기화 프로그램 실행
- 프로그램은 ROM(Read-Only Memory)나 EEPROM(Electrically Erasable Programmable Read-Only Memory)에 저장
  - 주로 펌웨어(Firmware)라고 불림
- 부트스트랩 프로그램 실행 순서
  - 시스템을 초기화하고 부트로더(Boot loader)를 실행
  - 부트 로더는 운영체제를 실행
  - 커널이 로드, 실행되면 시스템과 사용자에게 서비스를 제공
- 일부 서비스는 커널 외부에서 제공
  - 이들은 부팅할 때 메모리에 로드되는 시스템 프로세스(System processes)나 시스템 데몬(System daemons)
  - 데몬은 프로세스로 백그라운드에서 돌면서 시스템 로그를 남기는 등의 여러 작업 수행



### Computer-System Operation

- 장치 컨트롤러는 CPU에게 이벤트 발생을 알리는데, 이벤트 발생을 알리는 것을 인터럽트(Interrupt)라고 부름
- 여러 작업을 동시에 처리하는데, 이때 당장 처리해야 하는 일이 생기면 인터럽트를 보내 기존의 작업을 잠시 중단하고 인터럽트를 처리한 뒤 기존 작업으로 돌아옴
- 하드웨어에서는 시스템 버스를 통해 CPU에 신호를 보냄으로써 인터럽트를 발생
- 소프트웨어는 시스템 콜(System call)이라는 특별한 명령으로 인터럽트를 발생



### Common Functions of Interrupts

- CPU가 인터럽트 신호를 받으면 일을 잠시 멈추고 메모리의 어떤 고정된 위치(Fixed location)을 찾음. 이 위치는 인터럽트 벡터(Interrupt vector)에 저장
- 인터럽트 벡터는 인터럽트를 처리할 수 있는 서비스 루틴(Service routine)들의 주소를 가지고 있는 공간, 파일 읽기/쓰기와 같은 중요한 동작들이 하드코딩되어 있음
- 인터럽트 아키텍처는 인터럽트된 명령어의 주소를 저장
  - 운영체제는 레지스터와 프로그램 카운터를 저장하여 CPU의 상태를 보존
- 인터럽트 손실을 방지하기 위해 다른 인터럽트가 처리되는 동안 들어오는 인터럽트는 비활성화
  - 트랩은 오류 또는 사용자 요청에 의해 발생하는 소프트웨어 생성 인터럽트
  - 운영체제는 interrupts driven
- 참고) 어떤 값을 0으로 나누는 것(Division by zero)도 인터럽트. 내부 인터럽트(Internal interrupt)는 예외(Exception)라고 부름

![Interrupt Timeline](images/Interrupt%20Timeline.png)



### Interrupt Handling

- 운영체제들은 대부분 인터럽트 주도적(Interrupt driven).
- 인터럽트가 발생하기 전까지 CPU는 대기 상태
- 폴링(Polling)의 경우 주기적으로 이벤트를 감시해 처리 루틴을 실행. 디바이스가 적은 것에 용이



## Storage Structure

- 커널은 실행기(Executor)를 통해 프로그램을 실행
  - 실행기는 기억장치(Storage)에서 exe 파일(Windows의 경우)을 가져옴
  - 커널이 이를 메인 메모리(보통 RAM(Random-Access Memory))에 로드되어 실행시킴
  - 하지만 RAM은 모든 프로그램을 담기에 너무 작고 비싸고 전원이 나가면 데이터가 사라지는 휘발성(Volatile) 장치
  - 보조기억장치 필요
- 비휘발성(Non-volatile) 기억장치 - 자기테이프(Magnetic tapes), 광학디스크(Optical disk), 자기디스크(Magnetic disk), SSD(Soli-State Disk)
- 휘발성 기억장치 - 메인 메모리, 캐시(Cache), 레지스터(Registers)
- 보조기억장치는 용량이 크고 저렴한 반면, 캐시나 레지스터는 용량이 작고 비쌈
- 최대절전모드는 메모리의 모든 데이터를 덤프해서 보조기억장치에 담고, 절전모드가 끝나면 덤프해둔 데이터를 불러와 그대로 작업수행(하이버네이트(Hibernate))

![Storage Structure](images/Storage%20Structure.png)

![Storage Device Hierarchy](images/Storage%20Device%20Hierarchy.png)



## I/O Structure

- 기억장치는 여러 입출력장치 중 하나. 다양한 입출력 장치가 있으며 입출력 컨트롤러는 각각 다른 장치를 담당
- 운영체제는 각 장치 컨트롤러를 제어하기 위한 장치 드라이버(Device Driver)를 가짐
- 입출력 명령 수행 과정
  - 장치 드라이버는 장치 컨트롤러의 레지스터 로드
  - 장치 컨트롤러는 레지스터에서 "키보드로부터 문자 읽어오기"와 같은 동작을 읽음
  - 읽은 동작을 장치에서 로컬 버퍼로 데이터를 전송
  - 전송이 끝나면 장치 컨트롤러는 장치 드라이버(CPU)에게 인터럽트를 통해 끝났음을 알림
  - 장치 드라이버는 통제권을 운영체제에게 돌려줌
- 사용자 프로그램은 커널과 사용자 프로그램을 매개하는 인터페이스인 시스템 콜을 통해 입출력을 요청



## Direct Memory Access Structure

- 과거에는 장치 데이터 처리를 CPU를 거쳐 메모리에 로드하는 방식 사용
- 인터럽트 기반 I/O는 높은 오버 헤드로 인해 대량 데이터 이동에 적합하지 않음
- CPU 자원을 너무 많이 소모하여 최근에는 DMA(Direct Memory Access)를 사용
- DMA는 장치와 메모리를 직접 연결하는 방식, 버스가 지원하는 기능
- 장치의 데이터는 장치 컨트롤러에 의해 직접 메모리에 전달되며, CPU에서는 데이터 이동이 완료되었다는 인터럽트만 한번 일어남
- 바이트 당 인터럽트가 아닌 블록 당 하나의 인터럽트만 생성



## Computer-System Architecture

- 현대 컴퓨터 시스템은 기본적으로 폰 노이만 구조를 따름

![How A Modern Computer System Works](images/How%20A%20Modern%20Computer%20System%20Works.png)



### Single-Processor Systems

- 실글 프로세서 컴퓨터는 하나의 메인 CPU만 탑재하여 장치에 따라 특별한 목적을 가진 프로세서가 들어감



### Multiprocessor Systems

- 멀티 프로세서 컴퓨터는 2개 이상의 프로세서를 가짐
- 멀티 프로세서 시스템의 장점
  1. 처리량(Throughput)의 증가 : 프로세서가 늘어나면서 더 빠른 시간안에 연산을 수행할 수 있음
  2. 규모의 경제: 여러 대의 싱글 프로세서 시스템을 구축하는 것보다 돈이 적게 든다. 주변장치(Peripherals)를 공유할 수 있기 때문
  3. 신뢰성의 증가: 기능이 여러 프로세서에 분산되면 하나의 프로세서가 작동을 멈춰도 전체 시스템은 느려질 뿐 멈추지 않음(우아한 성능저하(Graceful degradation)). 이렇게 성능을 저하함으로써 작업을 계속 유지하는 시스템을 장애 허용 시스템(Fault tolerant)라고 부름
- 멀티 프로세서 시스템은 비대칭 멀티 프로세싱(Asymmetric multiprocessing)과 대칭 멀티 프로세싱(Symmetric multiprocessing) 두가지로 나뉨
  - 비대칭 멀티 프로세싱
    - 관료주의적 회사
    - 보스 프로세서가 시스템을 제어, 다른 프로세서들은 보스의 지시를 받음
    - 부하 분산(Loadbalancing)을 효율적으로 할 수 있음
    - 하지만 보스 프로세서가 작동을 멈추면 다른 프로세서들도 작동을 멈춤
  - 대칭 멀티 프로세싱
    - 보스가 없는 자유로운 회사
    - 모든 프로세서들은 하나의 메모리를 공유. 동일한 작업을 병렬적으로 수행
    - 프로세서에 이상이 생기면 수행하던 작업을 다른 프로세서들에게 보내주고 재부팅
- 멀티 프로세서 시스템의 CPU들은 각자의 레지스터와 캐시를 갖고 있음



### A Dual-Core Design

- CPU가 늘어나면 프로세서간 통신을 하는데 많은 비용이 들어 효율이 계속 좋아지지 않음
- 최근 CPU 설계 트랜드는 하나의 칩(Chip)에 코어(Cores)를 늘리는 것(멀티코어)
- 코어는 동일한 성ㄴ응의 CPU들을 1개의 칩 속에 접접한 것
- 칩 내부의 통신이(On-chip communication)이 칩 사이의 통신(Between-chip communication)보다 더 빠름
- 각 코어는 자신만의 레지스터와 로컬 캐시를 가짐(하나의 캐시를 공유하기도 함)



### Clustered Systems

- 클러스터 시스템은 여러 개의 CPU를 모아 놓은 구조
- 여러 개의 개별 시스템(또는 노드)들이 하나로 모여있다는 점에서 멀티프로세스 시스템과 조금 다름
  - 멀티프로세서 시스템은 여러 CPU가 하나의 시스템을 이룸
  - 클러스터 시스템은 여러 독립적인 시스템이 모여 하나의 시스템을 이룸(약결합(Loosely coupled))
- 클러스터링은 고가용성(High-availability) 서비스를 제공하기 위해 사용
- 비대칭 클러스터링(Asymmetric clustering)
  - 하나의 장비는 상시 대기 모드(Hot-standby mode)로 작동
  - 서버를 동작시키고 있는 다른 노드들은 모니터링만 수행
  - 서버에 문제가 생기면 상시 대기 노드가 서버로서 작동
- 대칭 클러스터링(Symmetric clustering)
  - 두 개 이상의 노드가 작업을 수행하는 동시에 다른 노드들을 모니터링하는 구조
  - 하드웨어의 자원을 최대로 사용할 수 있음
- 클러스터 시스템은 여러 개의 컴퓨터 시스템이 네트워크로 연결되는 구조
  - 고성능 컴퓨팅 환경(High-performance computing environments)를 제공
- 하지만 단일 시스템에 비해 유지보수가 힘듬. 성능이 네트워크 환경에 많은 영향을 받음



## Operating System Structure

- **멀티프로그래밍(Multiprogramming)**은 여러 프로그램을 메모리에 로드해 두고 한 프로세스가 대기 상태가 되면 다른 프로세스의 작업을 수행하는 시스템
- 더 확장된 시스템이 **시분할(Time sharing) 시스템**(다른 말로는 멀티태스킹(Multitasking))
  - 프로세스마다 작업 시간을 정해두고 번갈아가면서 작업하는 방식
  - 이때 반응 시간(Response time)을 줄이는 것이 중요함(< 1초)
- 시분할과 멀티프로그래밍 시스템은 여러 작업들을 메모리에 올리는 방식
- 운영체제는 메모리에 자리가 없으면 어떤 작업을 먼저 처리할지 정해야 함
  - 이 과정을 작업 스케줄링(Job Scheduling), CPU 스케줄링(CPU Scheduling)
- 메모리를 너무 많이 사용하면 시간을 줄이기 위해 가상 메모리(Virtual memory)를 사용



## Operating-System Operations

- 운영체제는 인터럽트 기반.
- 인터럽트가 없다면 시스템은 조용히 인터럽트를 기다림
- 운영체제와 사용자는 컴퓨터의 하드웨어, 소프트웨어 자원을 공유
- 때문에 사용자 프로그램이 오류를 일으키지 않도록 방지해야 함



## Dual-Mode and Multimode Operation

- 운영체제는 사용자 프로그램이 함부로 시스템에 접근하지 못하도록 유저 모드와 커널 모드로 나눔
- 하드웨어의 모드 비트가 0은 커널 모드 1은 유저 모드
- 하드웨어는 커널 모드일 때만 특권 명령(Privileged Instructions)를 실행
- 유저 모드에서 특권 명령을 실행하면 하드웨어는 막고 운영체제에게 트랩을 보냄
- System Call은 모드를 커널로 변경하고 호출에서 복귀하면 사용자에게 재설정



## Timer

- 운영체제는 사용자의 프로그램이 제어권을 운영체제에게 넘겨주지 않는 상황을 방지하기 위해 타이머를 사용
  - 무한 루프 / 프로세스 호깅 자원 방지를 위한 타이머
- 타이머는 운영체제에게 제어권을 보장하기 위해 특정 주기에 인터럽트를 발생



## Process Management

- 프로세스는 실행 중인 프로그램, 시스템 내의 작업 단위
- 디스크에 있으면 프로그램, 메모리에 로드되면 프로세스, 프로그램은 하나 프로세스는 여러개일 수 있음
- 프로그램은 수동적(Passive), 프로세스는 능동적(Active)
- 프로세스는 작ㅇ버을 수행하기 위해 리소스가 필요
  - CPU, 메모리, I/O 파일
  - 초기화 데이터
- 프로세스는 프로그램이 어디까지 실행되었는지 체크하는 프로그램 카운터를 가지고 있음
- 단일 스레드 프로세스는 하나의 프로그램 카운터
- 다중 스레드 프로세스는 스레드당 하나의 프로그램 카운터
- 운영체제는 프로세스 관리를 위해 CPU에게 프로세스와 쓰레드를 스케줄링, 프로세스를 생성 및 제거
  - 또한 일시정지하거나 재실행, 프로세스의 동기화와 통신도 제공



## Process Management Activities

- 운영체제는 프로세스 관리에 관련하여 다음 활동을 담당
  - 사용자 및 시스템 프로세스 생성 및 삭제
  - 프로세스 일시정지 및 재개
  - 프로세스 동기화를 위한 매커니즘 제공
  - 프로세스 커뮤니케이션을 위한 매커니즘 제공
  - 교착(Deadlock) 상태 처리를 위한 매커니즘 제공



## Memory Management

- 메인 메모리는 현대 컴퓨터 시스템의 핵심, 방대한 바이트의 배열
- 프로그램이 실행될 때 프로그램은 절대 주소로 매핑되어 메모리에 로드
- 운영체제는 메모리 관리를 위해 메모리의 어떤 부분이 어디에 쓰이는지, 누가 사용하는지, 어떤 프로세스와 데이터가 메모리의 안팎으로 옮겨질지 결정
- 또한 메모리 공간을 할당하고 해제



## Storage Management

- 운영체제는 저장장치의 물리적 속성을 추상화해 파일이라는 논리적 저장 단위로 정의



### File-System Management

- 운영체제는 파일을 생성, 제거, 읽기, 쓰기를 수행



### Mass-Storage Management

- 프로그램은 디스크에 담겨있으며, 메인 메모리에 로드되어 실행
- 많은 사람들이 제 3의 저장 장치(Tertiary Storage Devices)를 사용
- 저장 장치들은 WORM(Write-Once, Read-Many-Times)과 RW(Read-Write)형식에 차이가 있음
- NTFS, FAT가 파일 저장 형식, 이를 파일 시스템이라고 부름



### Caching

- 캐시는 굉장히 빠르고 작은 저장장치이며, 캐싱은 캐시 메모리를 사용해 컴퓨터의 속도를 높이는 기술
- 캐시에 자주 사용될 것 같은 데이터를 미리 담고 CPU나 디스크가 캐시의 데이터를 참조
- 파일의 중복성이 증가하지만 속도 역시 증가
- 캐싱은 지역성(Locality) 원리를 사용
- 시간 지역성(Temporal locality)
  - 한 번 접근한 데이터에 다시 접근할 확률이 높음
- 공간 지역성(Spatial Locality)
  - 특정 데이터와 가까운 메모리 주소에 있는 다른 데이터도 접근할 확률이 높음



### I/O System

- 운영체제는 모든 입출력 장치를 파일로 취급
- 오직 장치 드라이버만이 장치의 자세한 정보를 알고 있음



## Protection and Security

- 운영체제는 내외부로부터 컴퓨터를 보호하기 위해 다양한 활동을 함
  - 유저 모드와 커널 모드를 나눔

- 권한 확대(Privilege escalation)는 컴퓨터 시슽엠의 권한을 여러 층으로 나누고 사용자의 권한을 구분해 어떤 기준에 따라 사용자의 권한을 상승시키는 시스템

- 수직 권한 확대
  - 임의의 코드를 실행시켜 더 높은 권한을 얻는 행위

- 수평 권한 확대
  - 안드로이드 루팅, iOS 탈옥



## Kernel Data Structures

- 커널 구현에 사용되는 자료구조는 리스트, 스택, 큐, 링크드리스트, 트리

- 특히 트리는 상당히 효율적이기 때문에 자주 사용



## Computing Environments

- 모바일 컴퓨팅 환경
  - 컴퓨터의 접근성을 높이고 다양한 센서를 통해 사용자 인터페이스를 확장 시킴

- 이외의 컴퓨팅 환경
  - 분산형 컴퓨팅, 클라이언트-서버 컴퓨팅, P2P 컴퓨팅

- 클라우드 컴퓨팅은 AWS를 통해 많이 알려짐

- 현대 컴퓨팅 환경의 특징 – 휴대성, 가상화, 멀티코어



## Open-Source Operating Systems

- 오픈소스 운영체제 개발에는 누구나 참여가능하고 새로운 운영체제를 만들 수 있음

- ex) 리눅스